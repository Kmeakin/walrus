---
source: crates/walrus-codegen/src/tests.rs
expression: module

---
; ModuleID = 'module'
source_filename = "module"

%Option = type { i8, { i32 } }

define void @builtins.exit.wrapper(i8* %env, i32 %status) {
  call void @exit(i32 %status)
  unreachable
}

declare void @exit(i32)

define i32 @builtins.putchar.wrapper(i8* %env, i32 %c) {
  %1 = call i32 @putchar(i32 %c)
  ret i32 %1
}

declare i32 @putchar(i32)

define %Option @add_options(i8* %add_options.env, %Option %add_options.params.0, %Option %add_options.params.1) {
add_options.entry:
  %a.alloca = alloca %Option, align 8
  store %Option %add_options.params.0, %Option* %a.alloca, align 4
  %b.alloca = alloca %Option, align 8
  store %Option %add_options.params.1, %Option* %b.alloca, align 4
  %tuple.alloca = alloca { %Option, %Option }, align 8
  %a = load %Option, %Option* %a.alloca, align 4
  %tuple.0.gep = getelementptr inbounds { %Option, %Option }, { %Option, %Option }* %tuple.alloca, i32 0, i32 0
  store %Option %a, %Option* %tuple.0.gep, align 4
  %b = load %Option, %Option* %b.alloca, align 4
  %tuple.1.gep = getelementptr inbounds { %Option, %Option }, { %Option, %Option }* %tuple.alloca, i32 0, i32 1
  store %Option %b, %Option* %tuple.1.gep, align 4
  %tuple = load { %Option, %Option }, { %Option, %Option }* %tuple.alloca, align 4
  br label %match.case0.test

match.case0.test:                                 ; preds = %add_options.entry
  %tuple.0 = extractvalue { %Option, %Option } %tuple, 0
  %0 = extractvalue %Option %tuple.0, 0
  %1 = icmp eq i8 %0, 1
  br i1 %1, label %"match.case0.Option::Some.then", label %"match.case0.Option::Some.else"

"match.case0.Option::Some.then":                  ; preds = %match.case0.test
  %"Option::Some.payload" = extractvalue %Option %tuple.0, 1
  %Some.x = extractvalue { i32 } %"Option::Some.payload", 0
  br label %"match.case0.Option::Some.end"

"match.case0.Option::Some.else":                  ; preds = %match.case0.test
  br label %"match.case0.Option::Some.end"

"match.case0.Option::Some.end":                   ; preds = %"match.case0.Option::Some.then", %"match.case0.Option::Some.else"
  %"match.case0.Option::Some.phi" = phi i1 [ true, %"match.case0.Option::Some.then" ], [ false, %"match.case0.Option::Some.else" ]
  %2 = and i1 true, %"match.case0.Option::Some.phi"
  %tuple.1 = extractvalue { %Option, %Option } %tuple, 1
  %3 = extractvalue %Option %tuple.1, 0
  %4 = icmp eq i8 %3, 1
  br i1 %4, label %"match.case1.Option::Some.then", label %"match.case1.Option::Some.else"

"match.case1.Option::Some.then":                  ; preds = %"match.case0.Option::Some.end"
  %"Option::Some.payload1" = extractvalue %Option %tuple.1, 1
  %Some.x2 = extractvalue { i32 } %"Option::Some.payload1", 0
  br label %"match.case1.Option::Some.end"

"match.case1.Option::Some.else":                  ; preds = %"match.case0.Option::Some.end"
  br label %"match.case1.Option::Some.end"

"match.case1.Option::Some.end":                   ; preds = %"match.case1.Option::Some.then", %"match.case1.Option::Some.else"
  %"match.case1.Option::Some.phi" = phi i1 [ true, %"match.case1.Option::Some.then" ], [ false, %"match.case1.Option::Some.else" ]
  %5 = and i1 %2, %"match.case1.Option::Some.phi"
  br i1 %5, label %match.case0.then, label %match.case1.test

match.case0.then:                                 ; preds = %"match.case1.Option::Some.end"
  %tuple.03 = extractvalue { %Option, %Option } %tuple, 0
  %"Option::Some.payload4" = extractvalue %Option %tuple.03, 1
  %Some.x5 = extractvalue { i32 } %"Option::Some.payload4", 0
  %a.alloca6 = alloca i32, align 4
  store i32 %Some.x5, i32* %a.alloca6, align 4
  %tuple.17 = extractvalue { %Option, %Option } %tuple, 1
  %"Option::Some.payload8" = extractvalue %Option %tuple.17, 1
  %Some.x9 = extractvalue { i32 } %"Option::Some.payload8", 0
  %b.alloca10 = alloca i32, align 4
  store i32 %Some.x9, i32* %b.alloca10, align 4
  %"Option::Some.alloca" = alloca %Option, align 8
  %Option.discriminant.gep11 = getelementptr inbounds %Option, %Option* %"Option::Some.alloca", i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep11, align 1
  %a12 = load i32, i32* %a.alloca6, align 4
  %b13 = load i32, i32* %b.alloca10, align 4
  %6 = add i32 %a12, %b13
  %payload.gep = getelementptr inbounds %Option, %Option* %"Option::Some.alloca", i32 0, i32 1
  %"Option::Some.x.gep" = getelementptr inbounds { i32 }, { i32 }* %payload.gep, i32 0, i32 0
  store i32 %6, i32* %"Option::Some.x.gep", align 4
  %"Option::Some" = load %Option, %Option* %"Option::Some.alloca", align 4
  br label %match.end

match.case1.test:                                 ; preds = %"match.case1.Option::Some.end"
  br i1 true, label %match.case1.then, label %match.fail

match.case1.then:                                 ; preds = %match.case1.test
  %"Option::None.alloca" = alloca %Option, align 8
  %Option.discriminant.gep = getelementptr inbounds %Option, %Option* %"Option::None.alloca", i32 0, i32 0
  store i8 0, i8* %Option.discriminant.gep, align 1
  %"Option::None" = load %Option, %Option* %"Option::None.alloca", align 4
  br label %match.end

match.fail:                                       ; preds = %match.case1.test
  unreachable

match.end:                                        ; preds = %match.case0.then, %match.case1.then
  %match.phi = phi %Option [ %"Option::None", %match.case1.then ], [ %"Option::Some", %match.case0.then ]
  ret %Option %match.phi
}

define %Option @main(i8* %main.env) {
main.entry:
  %"Option::Some.alloca" = alloca %Option, align 8
  %Option.discriminant.gep = getelementptr inbounds %Option, %Option* %"Option::Some.alloca", i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep, align 1
  %payload.gep = getelementptr inbounds %Option, %Option* %"Option::Some.alloca", i32 0, i32 1
  %"Option::Some.x.gep" = getelementptr inbounds { i32 }, { i32 }* %payload.gep, i32 0, i32 0
  store i32 1, i32* %"Option::Some.x.gep", align 4
  %"Option::Some" = load %Option, %Option* %"Option::Some.alloca", align 4
  %a.alloca = alloca %Option, align 8
  store %Option %"Option::Some", %Option* %a.alloca, align 4
  %"Option::Some.alloca1" = alloca %Option, align 8
  %Option.discriminant.gep2 = getelementptr inbounds %Option, %Option* %"Option::Some.alloca1", i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep2, align 1
  %payload.gep3 = getelementptr inbounds %Option, %Option* %"Option::Some.alloca1", i32 0, i32 1
  %"Option::Some.x.gep4" = getelementptr inbounds { i32 }, { i32 }* %payload.gep3, i32 0, i32 0
  store i32 2, i32* %"Option::Some.x.gep4", align 4
  %"Option::Some5" = load %Option, %Option* %"Option::Some.alloca1", align 4
  %b.alloca = alloca %Option, align 8
  store %Option %"Option::Some5", %Option* %b.alloca, align 4
  %add_options.closure.alloca = alloca { %Option (i8*, %Option, %Option)*, i8* }, align 8
  %add_options.closure.code = getelementptr inbounds { %Option (i8*, %Option, %Option)*, i8* }, { %Option (i8*, %Option, %Option)*, i8* }* %add_options.closure.alloca, i32 0, i32 0
  store %Option (i8*, %Option, %Option)* @add_options, %Option (i8*, %Option, %Option)** %add_options.closure.code, align 8
  %add_options.closure.env = getelementptr inbounds { %Option (i8*, %Option, %Option)*, i8* }, { %Option (i8*, %Option, %Option)*, i8* }* %add_options.closure.alloca, i32 0, i32 1
  store i8* null, i8** %add_options.closure.env, align 8
  %add_options = load { %Option (i8*, %Option, %Option)*, i8* }, { %Option (i8*, %Option, %Option)*, i8* }* %add_options.closure.alloca, align 8
  %closure.code = extractvalue { %Option (i8*, %Option, %Option)*, i8* } %add_options, 0
  %closure.env = extractvalue { %Option (i8*, %Option, %Option)*, i8* } %add_options, 1
  %a = load %Option, %Option* %a.alloca, align 4
  %b = load %Option, %Option* %b.alloca, align 4
  %call = call %Option %closure.code(i8* %closure.env, %Option %a, %Option %b)
  ret %Option %call
}

