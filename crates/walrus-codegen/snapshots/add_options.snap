---
source: crates/walrus-codegen/src/tests.rs
expression: module

---
; ModuleID = 'module'
source_filename = "module"

%Option = type { i8, { i32 } }

define void @builtins.exit.wrapper(i8* %env, i32 %status) {
  call void @exit(i32 %status)
  unreachable
}

declare void @exit(i32)

define i32 @builtins.putchar.wrapper(i8* %env, i32 %c) {
  %1 = call i32 @putchar(i32 %c)
  ret i32 %1
}

declare i32 @putchar(i32)

define %Option @add_options(i8* %add_options.env, %Option %add_options.params.0, %Option %add_options.params.1) {
add_options.entry:
  %a.alloca = alloca %Option, align 8
  store %Option %add_options.params.0, %Option* %a.alloca, align 4
  %b.alloca = alloca %Option, align 8
  store %Option %add_options.params.1, %Option* %b.alloca, align 4
  %tuple.alloca = alloca { %Option, %Option }, align 8
  %a = load %Option, %Option* %a.alloca, align 4
  %tuple.0.gep = getelementptr inbounds { %Option, %Option }, { %Option, %Option }* %tuple.alloca, i32 0, i32 0
  store %Option %a, %Option* %tuple.0.gep, align 4
  %b = load %Option, %Option* %b.alloca, align 4
  %tuple.1.gep = getelementptr inbounds { %Option, %Option }, { %Option, %Option }* %tuple.alloca, i32 0, i32 1
  store %Option %b, %Option* %tuple.1.gep, align 4
  %tuple = load { %Option, %Option }, { %Option, %Option }* %tuple.alloca, align 4
  br label %match.case0.test

match.case0.test:                                 ; preds = %add_options.entry
  %tuple.0 = extractvalue { %Option, %Option } %tuple, 0
  %Option.discriminant = extractvalue %Option %tuple.0, 0
  %0 = icmp eq i8 %Option.discriminant, 1
  br i1 %0, label %"match.case0.Option::Some.then", label %"match.case0.Option::Some.else"

"match.case0.Option::Some.then":                  ; preds = %match.case0.test
  %Option.payload = extractvalue %Option %tuple.0, 1
  %"Option::Some.x" = extractvalue { i32 } %Option.payload, 0
  br label %"match.case0.Option::Some.end"

"match.case0.Option::Some.else":                  ; preds = %match.case0.test
  br label %"match.case0.Option::Some.end"

"match.case0.Option::Some.end":                   ; preds = %"match.case0.Option::Some.then", %"match.case0.Option::Some.else"
  %"match.case0.Option::Some.phi" = phi i1 [ true, %"match.case0.Option::Some.then" ], [ false, %"match.case0.Option::Some.else" ]
  %1 = and i1 true, %"match.case0.Option::Some.phi"
  %tuple.1 = extractvalue { %Option, %Option } %tuple, 1
  %Option.discriminant1 = extractvalue %Option %tuple.1, 0
  %2 = icmp eq i8 %Option.discriminant1, 1
  br i1 %2, label %"match.case1.Option::Some.then", label %"match.case1.Option::Some.else"

"match.case1.Option::Some.then":                  ; preds = %"match.case0.Option::Some.end"
  %Option.payload2 = extractvalue %Option %tuple.1, 1
  %"Option::Some.x3" = extractvalue { i32 } %Option.payload2, 0
  br label %"match.case1.Option::Some.end"

"match.case1.Option::Some.else":                  ; preds = %"match.case0.Option::Some.end"
  br label %"match.case1.Option::Some.end"

"match.case1.Option::Some.end":                   ; preds = %"match.case1.Option::Some.then", %"match.case1.Option::Some.else"
  %"match.case1.Option::Some.phi" = phi i1 [ true, %"match.case1.Option::Some.then" ], [ false, %"match.case1.Option::Some.else" ]
  %3 = and i1 %1, %"match.case1.Option::Some.phi"
  br i1 %3, label %match.case0.then, label %match.case1.test

match.case0.then:                                 ; preds = %"match.case1.Option::Some.end"
  %tuple.04 = extractvalue { %Option, %Option } %tuple, 0
  %Option.payload5 = extractvalue %Option %tuple.04, 1
  %"Option::Some.x6" = extractvalue { i32 } %Option.payload5, 0
  %a.alloca7 = alloca i32, align 4
  store i32 %"Option::Some.x6", i32* %a.alloca7, align 4
  %tuple.18 = extractvalue { %Option, %Option } %tuple, 1
  %Option.payload9 = extractvalue %Option %tuple.18, 1
  %"Option::Some.x10" = extractvalue { i32 } %Option.payload9, 0
  %b.alloca11 = alloca i32, align 4
  store i32 %"Option::Some.x10", i32* %b.alloca11, align 4
  %Option.alloca12 = alloca %Option, align 8
  %Option.discriminant.gep13 = getelementptr inbounds %Option, %Option* %Option.alloca12, i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep13, align 1
  %Option.payload.gep14 = getelementptr inbounds %Option, %Option* %Option.alloca12, i32 0, i32 1
  %a15 = load i32, i32* %a.alloca7, align 4
  %b16 = load i32, i32* %b.alloca11, align 4
  %4 = add i32 %a15, %b16
  %"Option::Some.x.gep" = getelementptr inbounds { i32 }, { i32 }* %Option.payload.gep14, i32 0, i32 0
  store i32 %4, i32* %"Option::Some.x.gep", align 4
  %Option.load17 = load %Option, %Option* %Option.alloca12, align 4
  br label %match.end

match.case1.test:                                 ; preds = %"match.case1.Option::Some.end"
  br i1 true, label %match.case1.then, label %match.fail

match.case1.then:                                 ; preds = %match.case1.test
  %Option.alloca = alloca %Option, align 8
  %Option.discriminant.gep = getelementptr inbounds %Option, %Option* %Option.alloca, i32 0, i32 0
  store i8 0, i8* %Option.discriminant.gep, align 1
  %Option.payload.gep = getelementptr inbounds %Option, %Option* %Option.alloca, i32 0, i32 1
  %Option.load = load %Option, %Option* %Option.alloca, align 4
  br label %match.end

match.fail:                                       ; preds = %match.case1.test
  unreachable

match.end:                                        ; preds = %match.case0.then, %match.case1.then
  %match.phi = phi %Option [ %Option.load, %match.case1.then ], [ %Option.load17, %match.case0.then ]
  ret %Option %match.phi
}

define %Option @main(i8* %main.env) {
main.entry:
  %Option.alloca = alloca %Option, align 8
  %Option.discriminant.gep = getelementptr inbounds %Option, %Option* %Option.alloca, i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep, align 1
  %Option.payload.gep = getelementptr inbounds %Option, %Option* %Option.alloca, i32 0, i32 1
  %"Option::Some.x.gep" = getelementptr inbounds { i32 }, { i32 }* %Option.payload.gep, i32 0, i32 0
  store i32 1, i32* %"Option::Some.x.gep", align 4
  %Option.load = load %Option, %Option* %Option.alloca, align 4
  %a.alloca = alloca %Option, align 8
  store %Option %Option.load, %Option* %a.alloca, align 4
  %Option.alloca1 = alloca %Option, align 8
  %Option.discriminant.gep2 = getelementptr inbounds %Option, %Option* %Option.alloca1, i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep2, align 1
  %Option.payload.gep3 = getelementptr inbounds %Option, %Option* %Option.alloca1, i32 0, i32 1
  %"Option::Some.x.gep4" = getelementptr inbounds { i32 }, { i32 }* %Option.payload.gep3, i32 0, i32 0
  store i32 2, i32* %"Option::Some.x.gep4", align 4
  %Option.load5 = load %Option, %Option* %Option.alloca1, align 4
  %b.alloca = alloca %Option, align 8
  store %Option %Option.load5, %Option* %b.alloca, align 4
  %add_options.closure.alloca = alloca { %Option (i8*, %Option, %Option)*, i8* }, align 8
  %add_options.closure.code = getelementptr inbounds { %Option (i8*, %Option, %Option)*, i8* }, { %Option (i8*, %Option, %Option)*, i8* }* %add_options.closure.alloca, i32 0, i32 0
  store %Option (i8*, %Option, %Option)* @add_options, %Option (i8*, %Option, %Option)** %add_options.closure.code, align 8
  %add_options.closure.env = getelementptr inbounds { %Option (i8*, %Option, %Option)*, i8* }, { %Option (i8*, %Option, %Option)*, i8* }* %add_options.closure.alloca, i32 0, i32 1
  store i8* null, i8** %add_options.closure.env, align 8
  %add_options = load { %Option (i8*, %Option, %Option)*, i8* }, { %Option (i8*, %Option, %Option)*, i8* }* %add_options.closure.alloca, align 8
  %closure.code = extractvalue { %Option (i8*, %Option, %Option)*, i8* } %add_options, 0
  %closure.env = extractvalue { %Option (i8*, %Option, %Option)*, i8* } %add_options, 1
  %a = load %Option, %Option* %a.alloca, align 4
  %b = load %Option, %Option* %b.alloca, align 4
  %call = call %Option %closure.code(i8* %closure.env, %Option %a, %Option %b)
  ret %Option %call
}

