---
source: crates/walrus-codegen/src/tests.rs
expression: llvm_module.print_to_string().to_string()

---
; ModuleID = 'module'
source_filename = "module"

define void @builtins.exit.wrapper(i8* %env, i32 %status) {
  call void @exit(i32 %status)
  unreachable
}

declare void @exit(i32)

define i32 @builtins.putchar.wrapper(i8* %env, i32 %c) {
  %1 = call i32 @putchar(i32 %c)
  ret i32 %1
}

declare i32 @putchar(i32)

define i32 @main(i8* %main.env) {
main.entry:
  %"Option::Some.alloca" = alloca { i8, { i32 } }, align 8
  %Option.discriminant.gep = getelementptr inbounds { i8, { i32 } }, { i8, { i32 } }* %"Option::Some.alloca", i32 0, i32 0
  store i8 1, i8* %Option.discriminant.gep, align 1
  %payload.gep = getelementptr inbounds { i8, { i32 } }, { i8, { i32 } }* %"Option::Some.alloca", i32 0, i32 1
  %"Option::Some.x.gep" = getelementptr inbounds { i32 }, { i32 }* %payload.gep, i32 0, i32 0
  store i32 1, i32* %"Option::Some.x.gep", align 4
  %"Option::Some" = load { i8, { i32 } }, { i8, { i32 } }* %"Option::Some.alloca", align 4
  %opt.alloca = alloca { i8, { i32 } }, align 8
  store { i8, { i32 } } %"Option::Some", { i8, { i32 } }* %opt.alloca, align 4
  %match.test.alloca = alloca { i8, { i32 } }, align 8
  %opt = load { i8, { i32 } }, { i8, { i32 } }* %opt.alloca, align 4
  store { i8, { i32 } } %opt, { i8, { i32 } }* %match.test.alloca, align 4
  br label %match.case0.test

match.case0.test:                                 ; preds = %main.entry
  %0 = load { i8, { i32 } }, { i8, { i32 } }* %match.test.alloca, align 4
  %1 = extractvalue { i8, { i32 } } %0, 0
  %2 = icmp eq i8 %1, 0
  br i1 %2, label %"match.case0.Option::None.then", label %"match.case0.Option::None.else"

"match.case0.Option::None.then":                  ; preds = %match.case0.test
  br label %"match.case0.Option::None.end"

"match.case0.Option::None.else":                  ; preds = %match.case0.test
  br label %"match.case0.Option::None.end"

"match.case0.Option::None.end":                   ; preds = %"match.case0.Option::None.then", %"match.case0.Option::None.else"
  %"match.case0.Option::None.phi" = phi i1 [ true, %"match.case0.Option::None.then" ], [ false, %"match.case0.Option::None.else" ]
  br i1 %"match.case0.Option::None.phi", label %match.case0.then, label %match.case1.test

match.case0.then:                                 ; preds = %"match.case0.Option::None.end"
  %"Option::None.payload" = extractvalue { i8, { i32 } } %0, 1
  br label %match.end

match.case1.test:                                 ; preds = %"match.case0.Option::None.end"
  %3 = load { i8, { i32 } }, { i8, { i32 } }* %match.test.alloca, align 4
  %4 = extractvalue { i8, { i32 } } %3, 0
  %5 = icmp eq i8 %4, 1
  br i1 %5, label %"match.case1.Option::Some.then", label %"match.case1.Option::Some.else"

"match.case1.Option::Some.then":                  ; preds = %match.case1.test
  %"Option::Some.payload" = extractvalue { i8, { i32 } } %3, 1
  %"Option::Some.x" = extractvalue { i32 } %"Option::Some.payload", 0
  br label %"match.case1.Option::Some.end"

"match.case1.Option::Some.else":                  ; preds = %match.case1.test
  br label %"match.case1.Option::Some.end"

"match.case1.Option::Some.end":                   ; preds = %"match.case1.Option::Some.then", %"match.case1.Option::Some.else"
  %"match.case1.Option::Some.phi" = phi i1 [ true, %"match.case1.Option::Some.then" ], [ false, %"match.case1.Option::Some.else" ]
  br i1 %"match.case1.Option::Some.phi", label %match.case1.then, label %match.fail

match.case1.then:                                 ; preds = %"match.case1.Option::Some.end"
  %"Option::Some.payload1" = extractvalue { i8, { i32 } } %3, 1
  %"Option::Some.x2" = extractvalue { i32 } %"Option::Some.payload1", 0
  %x.alloca = alloca i32, align 4
  store i32 %"Option::Some.x2", i32* %x.alloca, align 4
  %x = load i32, i32* %x.alloca, align 4
  br label %match.end

match.fail:                                       ; preds = %"match.case1.Option::Some.end"
  unreachable

match.end:                                        ; preds = %match.case0.then, %match.case1.then
  %match.phi = phi i32 [ %x, %match.case1.then ], [ 0, %match.case0.then ]
  ret i32 %match.phi
}

