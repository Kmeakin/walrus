\chapter{Language reference}\label{chapter:reference}

\section{Identifiers}\label{section:reference:identifiers}
Identifiers are used in Walrus to signify any entity that requires a name:
local variables, functions, structs and enums, and fields.
Identifiers may consist of any sequence of alphabetic characters, digits, and underscores,
as long as the resulting identifier would not be a single underscore or a decimal integer.

% TODO: unicode identifiers
\begin{minted}{rust}
abcXYZ
hello_world // Identifiers can include underscores
_hello      // or start with underscores
_           // but a single underscore is not an identifier

the_number_123 // Identifiers can include digits
123abc         // but they cannot start with digits
\end{minted}

\section{Literals}\label{section:reference:Primitive datatypes}
Walrus has 5 primitive types (Bool, Int, Float, Char, String), with corresponding syntax
for creating literal values of these types.

\subsection{Bools}\label{section:reference:bools}
The \rust{Bool} datatype represents the logical values true and false of Boolean algebra.
Since there are only 2 possible values of this datatype, each \rust{Bool} value occupies
one byte of memory.

\begin{minted}{rust}
true
false
\end{minted}

\subsection{Ints}\label{section:reference:ints}
The \rust{Int} datatype represents signed 32-bit integers:
that is, integers between $-2^{31}$ ($-2,147,483,648$) and $2^{31}-1$ ($2,147,483,647$) inclusive.
\rust{Int} literals may be given in either decimal, binary or hexadecimal notation.
Underscores may be included in the \rust{Int} literals to enhance readability of long literals.

\begin{minted}{rust}
0b101                   // Binary integer literals
123_456_789_0           // Decimal integer literals
0x123_456_789_abc_def   // Hexadecimal integer literals
\end{minted}


Note that sign prefixes (\rust{+} or \rust{-}) are \textit{not} part of \rust{Int} literals:
they are unary operators: hence the code \rust{-123} is actually lexed and parsed as
a unary operator followed by a decimal integer literal.

Walrus currently only has one integer type: this is in contrast to most other strongly
typed languages, which have several different types representing integers of different
signedness and bit-width\footnote{See the \cc{char}, \cc{short}, \cc{int}, \cc{long},
    \cc{long long} hierarchy and \cc{signed}/\cc{unsigned} modifiers in C, \\
    or the \rust{i8}/\rust{u8} upto \rust{i128}/\rust{u128} types in Rust}.There is no technical reason other integer types could not also be included in Walrus:
they were simply ommitted for lack of time.

\subsection{Floats}\label{section:reference:floats}
The \rust{Float} datatype represents 32-bit floating point real numbers: to be precise,
the binary32 format specified in IEEE-754-2008. This allows representing rational numbers
between $-3.40282347 \times 10^{38}$ and $3.40282347 \times 10^{38}$, as well as positive and negative infinity, negative zero, and various NaN values.

\rust{Float} literals are given in decimal notation, with a decimal point separating the
integral and fractional parts of the number.
Scientific notation (such as \rust{1.0e6} for one million) is not currently supported.

\begin{minted}{rust}
1_000_000.05 // Decimal float literals
\end{minted}

As with \rust{Int} literals, sign prefixes are treated as separate unary operators and not part of the
\rust{Float} literal. Again, Walrus currently only has one floating point type, as opposed to the usual
two for binary32 and binary64 supported by most languages.
\footnote{See the \cc{float} and \cc{double} types in C,
    or \rust{f32} and \rust{f64} types in Rust}

\subsection{Chars}\label{section:reference:chars}
To a first approximation, the \rust{Char} datatype represents single textual characters.
However, unlike the \cc{char} datatype in C, which may represent a 7-bit ASCII value,
a 16-bit UTF16 code-unit, or a 8-bit UTF8 code-unit depending on the platform,
\rust{Char}s in Walrus take thier cue from Rust's \rust{char} datatype, which is capable of
representing Unicode characters.

Specifically, each \rust{Char} is a `Unicode scalar value'
\footnote{See \url{https://www.unicode.org/glossary/#unicode_scalar_value}}:
ie any Unicode codepoint\footnote{See \url{https://www.unicode.org/glossary/#code_point}} except for surrogates, which are an artifact of the UTF16 encoding.
This corresponds to any integer value between $0$ and $D7FF_{16}$ or $E000_{16}$ and $10FFFF_{16}$
inclusive.
As a consequence, each \rust{Char} value occupies 4 bytes in memory, even if it is an ASCII character that could
fit within one byte.

\rust{Char} literals are given by enclosing a character within single-quotes, \rust{'}. The enclosed character can be entered verbatim
if it is easily typeable on the user's keyboard, or by specifying the exact Unicode scalar value in hexadecimal notation if a exotic character is needed.
A few commonly used non-graphic characters can also be given in the shorthand backslash-escape syntax inherited from C

% TODO: unicode characters
\begin{minted}{rust}
'a'         // The first letter of the Latin alphabet
'\u{1f9ad}' // The same seal emoji 
'\n'        // A newline
\end{minted}

The possible backslash-escaped characters:

\begin{tabular}{ clc }
    Character              & Description     & Unicode scalar value \\
    \toprule
    \verb$'\n'$ & newline         & $U+000A$             \\
    \verb$'\r'$ & carraige return & $U+000D$             \\
    \verb$'\t'$ & horizontal tab  & $U+0072$             \\
    \verb$'\0'$ & null character  & $U+0000$             \\
    \verb$'\''$ & single quote    & $U+0000$             \\
    \verb$'\"'$ & double quote    & $U+0000$             \\
    \verb$'\\'$ & backslash       & $U+005C$             \\
    \bottomrule
\end{tabular}

\subsection{Strings}\label{section:reference:strings}
The \rust{String} datatype represents UTF-8 encoded textual data.

String literals are given by enclosing the text within double-quotes, \rust{"}. As with the syntax for \rust{Char} literals, the characters
may be entered either verbatim, by giving the unicode code point, or by using backslash-escapes:

% TODO: unicode characters
\begin{minted}{rust}
"Hello, world!\n"           
"Hello,\u{20}world!\u{0A}" 
\end{minted}


Unlike C's `strings', which are really just a pointer to a null-terminated sequence
of characters, Walrus \rust{String}s are represented as a pair of (length, pointer to character data).

String literals, whose contents are always known at compile-time, contain pointers to character data stored in
the read-only \texttt{.data} section of the final executable. All other strings, created by operations such as
converting other datatypes to strings or concatenating two strings together, cannot in general have their contents
known at compile time, and so store a pointer to heap-allocated memory containing their contents.

This representation offers several advantages over the C-style representation:
\begin{itemize}
    \item \textbf{Time complexity}: Calculating the length of a null-terminated string takes $O(n)$ time (ie proportional to the length of the string),
          as the string must be searched byte by byte from the start until a null-byte is encountered.
          By contrast, the (length, pointer) representation allows the length to be looked up trivially in $O(1)$ (ie constant) time simply by reading the value of the
          length field. A little extra care is required to ensure that operations on strings correctly update the length field, but this is usually simple.
    \item \textbf{Safety} If the terminating null-byte is ommitted, attempts to calculate the length of the string will blindly continue searching past the end of the string,
          and either return an overestimate of the string's length (if a null byte belonging to another object is encountered), or cause a memory protection fault if the search
          crosses into priveleged or nonexistant memory. Since the primary requirement of Walrus is that it should be impossible for normal code to trigger undefined behaviour
          or violate memory safety, this makes the use of null-terminated strings unacceptable.
    \item \textbf{Flexibility} C-style strings are incapable of representings strings containing null bytes, since a null-byte by definition marks the end of a string.
          Therefore a string such as \rust{"Hello,\0world"} would be truncated to \rust{"Hello,"} when passed to functions such as \cc{printf}. However, the null-byte is
          a Unicode character in its own right (U+0000), and a string representation that cannot include null-characters does not faithfully represent all possible Unicode
          strings.
\end{itemize}

The only disadvantage of this choice of representation is that each string occupies more space on the stack:
4 bytes for the length plus one word-sized pointer, vs one word-sized pointer. In the 1970s when C was developed
and computer memory was measured in kilobytes, saving every byte of memory was a concern. However, on modern computers
with several gigabytes of memory, a 4-byte overhead per string is a small price to pay in exchange for all of the afformentioned benefits.

\section{Let bindings}\label{section:reference:let_bindings}
Local variables are introduced with the \textbf{let-statement}:

\begin{minted}{rust}
let x = 5;
\end{minted}

Optional \textbf{type annotations} may be supplied, but most of the time
Walrus' type inference is sophisticated enough to infer the type of the binding
without needing an explicit annotation:
\begin{minted}{rust}
let x: Int = 5;
\end{minted}

Once defined, a variable is \textit{in-scope} and can be used in subsequent expressions
(it is an error to attempt to refer to a local variable before it has been defined):
\begin{minted}{rust}
let x = 5;
let y = 6;
let z = x + y;
\end{minted}

All local variables are immutable by default in Walrus. To mutate a variable, mutability
must be explictly opted-into by modifying the variable with the \rust{mut} keyword:
\begin{minted}{rust}
let mut x = 5;
x = x + 1;
\end{minted}

% TODO: what are the benefits of mutability by default?

Note that Walrus requires a variable to be declared and initialized in the same statement.
It is not possible to declare a variable as unitialized and then initalize it by mutating
it later, as in C. This is to avoid the possibility of triggering undefined-behaviour by
reading from a variable before it has been initalized:
\begin{minted}{c}
int x;
printf("The value contained in x is: %d\n", x);
\end{minted}

Rust \textit{does} allow separating a variables definition and initialisation, by performing
a dataflow analysis to check that every variable has been initialised in every possible
path of control flow before it is first read from. This feature was left out of Walrus
for lack of time.

\section{Arithmetic operators}\label{section:reference:operators}
Every programming language has certain operations that are so basic that they
cannot implemented in the source language itself, and must be provided by the implementation.
In Walrus, these are provided by operators and builtin functions
(see section~\ref{section:reference:builtin_functions}).

Unlike functions, operators have their own rules of \textit{precedence} and \textit{associativity},
which determines the final parse tree produced by the parser. For example, the expression
\rust{1 + 2 * 3 - 4}, allows the user to express in standard mathematical notation what would
otherwise have to be written as \rust{mul(add(1, 2), sub(3, 4))}


\begin{tabular}{ clc }
    Operator                           & Associativity \\
    \toprule
    Unary \rust{-}, \rust{*}, \rust{!} & Left          \\
    \rust{*}, \rust{/}                 & Left          \\
    \rust{+}, \rust{-}                 & Left          \\
    \rust{==}                          & Left          \\
    \rust{and}                         & Left          \\
    \rust{or}                          & Left          \\
    \rust{=}                           & Right         \\
    \bottomrule
\end{tabular}


Operators are also different from functions in that they are not truely \textit{first-class}.
They cannot be stored in variables, or passed to functions. This makes them less flexible
than operators in Haskell or ML, where a binary operator can be treated as a normal variable
by enclosing it in parentheses: \textit{(+)}, allowing them to be passed around as any other
function: \textit{foldr xs 0 (+)}.

However, this lack of first-class treatment also allows Walrus' operators be to used
as a source of \textit{ad-hoc polymorphism} (wherein the same name may refer to different implementations
with different types) without requiring an extension of the type system. Since the set of operators
is fixed, and operators can only be immediatly applied, never treated as values in themself, the correct
implementation of operator can be chosen during type inference by inspecting its arguments.

To treat operators as both truely first-class, and ad-hoc polymporphic, would require introducing
a system of \textit{qualified polymorphism}, as in Haskell's \textit{type-classes} or Rust's \textit{traits},
allowing the equality operator to be typed as \textit{(==) :: forall a. Eq a => a -> a -> bool}.

To see what happens when a language attempts to have first-class operators without a system for expressing
constrained polymorphism, look to OCaml: operators can be treated as first-class values, as in Haskell,
but Ocaml's polymorphism is only \textit{parametric}: a polymporphic function must have a single
implementation valid for any possible type, and it cannot perform any type-specific operations
on its arguments. As a result, the operators \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, operate
only on integers, and separate operators \texttt{+.}, \texttt{-.}, \texttt{*.}, \texttt{/.} are required
for performing the same operations on floats.

Clearly a system of qualified polymorphism would be desirable to have in Walrus, however it's implementation is very complex, and so has been
left out, with the current list of fixed operator implementations serving as a stop-gap solution.

% TODO: table of operator types

\section{Functions and closures}\label{section:reference:functions_and_closures}
\section{Builtin functions}\label{section:reference:builtin_functions}
\section{Control flow}\label{section:reference:control_flow}
\section{Tuples}\label{section:reference:tuples}
\section{Structs}\label{section:reference:structs}
\section{Enums}\label{section:reference:enums}
\section{Pattern matching}\label{section:reference:pattern_matching}
\section{Type inference}\label{section:reference:type_inference}
